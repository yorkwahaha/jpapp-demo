<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥èªåŠ©è© RPGï¼šé­”ç‹åŸå¤§å†’éšª</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@500;700&family=Noto+Sans+TC:wght@500;700&display=swap" rel="stylesheet">
    <style>
        [v-cloak] { display: none; }
        body { font-family: 'Noto Sans TC', 'Noto Sans JP', sans-serif; background: linear-gradient(180deg, #1e293b 0%, #0f172a 50%, #1e1b4b 100%); min-height: 100vh; color: #e2e8f0; }
        rt { font-size: 0.45em; color: #fcd34d; font-weight: normal; }
        .particle-input { border-bottom: 3px solid #f59e0b; width: 3.5rem; text-align: center; font-weight: bold; background: rgba(30, 41, 59, 0.8); color: #fef3c7; border-radius: 0.25rem; transition: all 0.2s; }
        .particle-input:focus { background: rgba(245, 158, 11, 0.2); outline: none; border-color: #fbbf24; }
        .correct { color: #059669; border-color: #059669; background: rgba(5, 150, 105, 0.2); color: #6ee7b7; }
        .wrong { color: #dc2626; border-color: #dc2626; background: rgba(220, 38, 38, 0.2); color: #fca5a5; }
        .choice-btn { transition: all 0.2s; }
        .card { backdrop-filter: blur(10px); background: rgba(30, 41, 59, 0.95); border: 1px solid rgba(148, 163, 184, 0.2); }
        .grammar-card { background: #422006; border: 1px solid #b45309; border-left: 4px solid #f59e0b; }
        .hp-bar-wrap { background: rgba(0,0,0,0.3); border-radius: 9999px; overflow: hidden; }
        .hp-bar-fill { height: 100%; border-radius: 9999px; transition: width 0.5s ease; }
        .hp-bar-fill.danger { background: #dc2626 !important; }
        @keyframes monster-shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px)} 75%{transform:translateX(4px)} }
        @keyframes player-blink { 0%,100%{opacity:1} 50%{opacity:0.3} }
        .monster-shake { animation: monster-shake 0.4s ease-in-out; }
        .player-blink { animation: player-blink 0.5s ease-in-out 2; }
        /* DQæˆ°é¬¥ç‰¹æ•ˆ */
        @keyframes shake { 0%,100%{transform:translate(0)} 20%,80%{transform:translate(-4px,2px)} 40%,60%{transform:translate(4px,-2px)} }
        .shake { animation: shake 0.25s ease-in-out; }
        @keyframes hit { 0%{transform:scale(1);filter:brightness(100%)} 25%{transform:scale(1.1);filter:brightness(150%)} 50%{transform:scale(1);filter:brightness(100%)} 75%{transform:scale(1.1);filter:brightness(150%)} 100%{transform:scale(1);filter:brightness(100%)} }
        .hit { animation: hit 0.25s ease-in-out; }
        .flash-overlay { position: fixed; inset:0; background:#fff; opacity:0; pointer-events:none; animation: flash 0.3s ease-out; z-index:50; }
        @keyframes flash { 0%{opacity:1} 100%{opacity:0} }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="app" v-cloak :class="{ shake: screenShake }" class="max-w-2xl mx-auto">
        <!-- audio controls -->
        <div class="flex justify-end gap-4 mb-2 text-xs">
            <button @click="isMuted = !isMuted; saveAudioSettings(); playBgm();" class="hover:underline">
                {{ isMuted ? 'ğŸ”ˆ' : 'ğŸ”‡' }}
            </button>
            <label class="flex items-center gap-1">BGM
                <input type="range" min="0" max="1" step="0.01" v-model.number="bgmVolume" @input="playBgm(); saveAudioSettings()">
            </label>
            <label class="flex items-center gap-1">SFX
                <input type="range" min="0" max="1" step="0.01" v-model.number="sfxVolume" @input="saveAudioSettings()">
            </label>
        </div>
        <!-- é—œå¡åœ°åœ–é¸å–® -->
        <div v-if="showLevelSelect" class="card rounded-3xl shadow-2xl overflow-hidden border border-amber-500/30 p-8 text-center">
            <h1 class="text-2xl font-black text-amber-400 mb-2">æ—¥èªåŠ©è© RPGï¼šé­”ç‹åŸå¤§å†’éšª</h1>
            <p class="text-slate-400 mb-4">é¸æ“‡é›£åº¦</p>
            <div class="flex justify-center gap-4 mb-8">
                <button @click="difficulty = 'easy'" :class="difficulty === 'easy' ? 'border-emerald-500 bg-emerald-500/20 text-emerald-300' : 'border-slate-600 text-slate-400 hover:border-slate-500'"
                    class="px-6 py-3 rounded-xl border-2 font-bold transition-all">Easy</button>
                <button @click="difficulty = 'hard'" :class="difficulty === 'hard' ? 'border-rose-500 bg-rose-500/20 text-rose-300' : 'border-slate-600 text-slate-400 hover:border-slate-500'"
                    class="px-6 py-3 rounded-xl border-2 font-bold transition-all">Hard</button>
            </div>
            <p class="text-slate-400 mb-2 text-sm"><span v-if="difficulty === 'easy'">ç­”éŒ¯å¾Œ 2 ç§’å¯é»ä¸‹ä¸€é¡Œ</span><span v-else>ç­”éŒ¯ / æ™‚é–“åˆ°å¾Œ 3 ç§’è‡ªå‹•ä¸‹ä¸€é¡Œ</span></p>
            <p class="text-slate-400 mb-8">é¸æ“‡è¦æŒ‘æˆ°çš„é—œå¡</p>
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                <button @click="startLevel(1)" class="p-6 rounded-2xl bg-emerald-900/40 border-2 border-emerald-500/50 hover:border-emerald-400 hover:bg-emerald-800/40 transition-all text-left">
                    <span class="text-4xl block mb-2">ğŸŒ²</span>
                    <span class="font-bold text-slate-200">æ£®æ—</span>
                    <span class="block text-sm text-slate-400">ç¬¬ 1 é—œ</span>
                </button>
                <button @click="startLevel(2)" class="p-6 rounded-2xl bg-slate-700/40 border-2 border-slate-500/50 hover:border-amber-500 hover:bg-slate-600/40 transition-all text-left">
                    <span class="text-4xl block mb-2">ğŸ•³ï¸</span>
                    <span class="font-bold text-slate-200">æ´çªŸ</span>
                    <span class="block text-sm text-slate-400">ç¬¬ 2 é—œ</span>
                </button>
                <button @click="startLevel(3)" class="p-6 rounded-2xl bg-rose-900/40 border-2 border-rose-500/50 hover:border-rose-400 hover:bg-rose-800/40 transition-all text-left">
                    <span class="text-4xl block mb-2">ğŸ°</span>
                    <span class="font-bold text-slate-200">é­”ç‹åŸ</span>
                    <span class="block text-sm text-slate-400">ç¬¬ 3 é—œ</span>
                </button>
            </div>
        </div>

        <div v-else class="card rounded-3xl shadow-2xl overflow-hidden border border-white/50 min-h-[600px] flex flex-col">
            <!-- èƒŒåŒ… -->
            <div class="bg-slate-900/60 border-b border-slate-600 px-4 py-2 flex items-center justify-between">
                <span class="text-xs text-slate-400 font-bold uppercase">èƒŒåŒ…</span>
                <button v-if="inventory.potions > 0 && player.hp < player.maxHp && !monsterDead && !playerDead" @click="usePotion"
                    class="flex items-center gap-2 px-4 py-2 rounded-lg bg-emerald-600/80 hover:bg-emerald-500 text-white text-sm font-bold">
                    ğŸ§ª å›å¾©è—¥æ°´ Ã— {{ inventory.potions }} <span class="text-xs">(+30 HP)</span>
                </button>
                <span v-else class="text-slate-500 text-sm">ğŸ§ª å›å¾©è—¥æ°´ Ã— {{ inventory.potions }}</span>
            </div>
            <!-- æˆ°é¬¥ç•«é¢ -->
            <div class="bg-slate-800/80 border-b border-slate-600 p-4 md:p-6">
                <h1 class="text-center text-lg font-black text-amber-400 mb-4">æ—¥èªåŠ©è© RPG Â· {{ levelTitle }} Â· ç¬¬ {{ currentLevel }} é—œ Â· {{ difficulty === 'easy' ? 'Easy' : 'Hard' }}</h1>
                <button @click="showMistakesPanel = !showMistakesPanel" class="text-xs text-amber-400 underline mb-2">éŒ¯é¡Œæœ¬</button>
                <div v-if="showMistakesPanel" class="bg-slate-800/90 p-4 rounded-xl mb-4 max-h-64 overflow-y-auto text-sm">
                    <div v-if="mistakes.length===0" class="text-slate-400">å°šç„¡éŒ¯é¡Œã€‚</div>
                    <div v-else>
                        <div v-for="(m,i) in mistakes" :key="i" class="mb-3 border-b border-slate-600 pb-2">
                            <div>é¡Œç›®ï¼š{{m.prompt}}</div>
                            <div>ç­”æ¡ˆï¼š{{ Array.isArray(m.correct) ? m.correct.join('/') : m.correct }}</div>
                            <div v-if="m.choices">é¸é …ï¼š{{m.choices.join(' ')}}</div>
                            <div v-if="m.grammarTip" class="text-xs text-amber-300">TIPï¼š{{m.grammarTip}}</div>
                            <div class="text-xs text-slate-400">{{m.timestamp}} (é—œå¡{{m.levelId}})</div>
                        </div>
                        <button @click="clearMistakes" class="text-red-400 text-xs underline">æ¸…ç©º</button>
                    </div>
                </div>
                <div class="flex justify-between items-stretch gap-4 mb-4">
                    <!-- ç©å®¶ -->
                    <div class="flex-1 flex flex-col items-center p-3 rounded-xl bg-slate-700/50 border border-emerald-500/30">
                        <div class="w-16 h-16 rounded-full bg-emerald-600 flex items-center justify-center text-3xl mb-2" :class="{ 'player-blink': playerBlink }">ğŸ§™</div>
                        <span class="text-xs text-slate-400 mb-1">å‹‡è€…</span>
                        <div class="w-full hp-bar-wrap h-3 mb-1" style="max-width: 120px;">
                            <div class="hp-bar-fill bg-emerald-500" :class="{ danger: hpBarDanger }" :style="{ width: (player.hp / player.maxHp * 100) + '%' }"></div>
                        </div>
                        <span class="text-xs font-mono text-emerald-300">{{ player.hp }} / {{ player.maxHp }}</span>
                        <div class="text-xs text-amber-400 mt-1">ğŸ’° {{ player.gold }} Â· â­ {{ player.exp }} <span v-if="comboCount > 0" class="text-rose-300">Â· {{ comboCount }} é€£æ“Š</span></div>
                    </div>
                    <!-- æˆ°é¬¥è¨˜éŒ„ -->
                    <div class="flex-1 flex items-center justify-center min-h-[80px] px-3 py-2 rounded-xl bg-slate-900/80 border border-slate-600">
                        <p class="text-sm text-center text-slate-300">{{ battleLog }}</p>
                    </div>
                    <!-- æ€ªç‰© -->
                    <div class="flex-1 flex flex-col items-center p-3 rounded-xl bg-slate-700/50 border border-rose-500/30" :class="{ hit: monsterHit }">
                        <div class="w-16 h-16 rounded-full bg-rose-700 flex items-center justify-center text-3xl mb-2">
                            {{ monster.sprite || 'ğŸ‘¹' }}
                        </div>
                        <span class="text-xs text-slate-400 mb-1">{{ monster.name }}</span>
                        <span class="text-xs text-amber-300 mb-1">{{ monster.trait }}</span>
                        <div class="w-full hp-bar-wrap h-3 mb-1" style="max-width: 120px;">
                            <div class="hp-bar-fill bg-rose-500" :style="{ width: (monster.hp / monster.maxHp * 100) + '%' }"></div>
                        </div>
                        <span class="text-xs font-mono text-rose-300">{{ monster.hp }} / {{ monster.maxHp }}</span>
                    </div>
                </div>
                <div class="flex justify-between items-center text-xs text-slate-400">
                    <span v-if="!isFinished && !hasSubmitted" class="flex items-center gap-2">â± å‰©é¤˜ <span class="font-bold text-amber-400" :class="timeLeft <= 3 ? 'animate-pulse' : ''">{{ timeLeft }}</span> ç§’</span>
                    <span v-else></span>
                    <span>ç¬¬ {{ currentIndex + 1 }} / 10 é¡Œ</span>
                </div>
                <div v-if="!isFinished && !hasSubmitted" class="w-full h-1.5 rounded-full bg-slate-700 mt-2 overflow-hidden">
                    <div class="h-full bg-amber-500 rounded-full transition-all duration-1000" :style="{ width: (timeLeft/10)*100 + '%' }"></div>
                </div>
            </div>

            <div class="p-6 md:p-8 flex-grow flex flex-col">
                <div v-if="!isFinished" class="flex-grow">
                    <template v-if="!monsterDead && !playerDead">
                    <div class="bg-slate-700/50 rounded-2xl p-6 mb-6 border border-slate-600">
                        <div class="text-amber-400 font-bold text-xs uppercase tracking-widest mb-2">é¡Œç›®</div>
                        <div class="text-xl text-slate-200 font-bold leading-relaxed">{{ currentQuestion.chinese }}</div>
                    </div>

                    <div class="text-3xl md:text-4xl flex flex-wrap items-end gap-x-3 gap-y-8 mb-4 min-h-[80px] leading-relaxed">
                        <template v-for="(seg, idx) in displaySegments">
                            <span v-if="!seg.isBlank" class="text-slate-100">
                                <ruby v-if="seg.ruby">{{ seg.text }}<rt>{{ seg.ruby }}</rt></ruby>
                                <span v-else>{{ seg.text }}</span>
                            </span>
                            <div v-else-if="seg.showInput && !isChoiceMode" class="flex flex-col items-center">
                                <input 
                                    v-model="userAnswers[seg.blankIndex]"
                                    :disabled="hasSubmitted"
                                    class="particle-input px-2 py-1"
                                    :class="getInputStyle(seg.blankIndex)"
                                    type="text"
                                    spellcheck="false">
                            </div>
                            <span v-else-if="seg.showInput && isChoiceMode" class="inline-block px-4 py-1 min-w-[3rem] text-center border-b-2 border-dashed border-amber-500/50" :class="getInputStyle(seg.blankIndex)">
                                {{ hasSubmitted ? getAnswerForDisplay(seg.blankIndex) : (userAnswers[seg.blankIndex] || 'ï¼¿') }}
                            </span>
                            <span v-else class="particle-input correct inline-block px-2 py-1">{{ getAnswerForDisplay(seg.blankIndex) }}</span>
                        </template>
                        
                        <button v-if="hasSubmitted" @click="playVoice" class="bg-amber-500 text-slate-900 p-3 rounded-full shadow-lg hover:scale-110 transition-transform">
                            <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M11 5a1 1 0 011 1v8a1 1 0 01-1 1l-3.293-3.293a1 1 0 00-.707-.293H5a1 1 0 01-1-1V9a1 1 0 011-1h1a1 1 0 00.707-.293L11 5z"></path></svg>
                        </button>
                    </div>
                    <div v-if="isChoiceMode && currentQuestion.choices && !hasSubmitted" class="flex flex-wrap justify-center gap-3 mb-8 p-4 rounded-xl bg-slate-800/50 border border-slate-600">
                        <span class="w-full text-xs text-slate-400 text-center mb-2">é¸æ“‡åŠ©è©</span>
                        <button v-for="opt in currentQuestion.choices" :key="opt" @click="selectChoice(opt)"
                            class="choice-btn px-6 py-3 rounded-xl text-xl font-bold border-2"
                            :class="getChoiceBtnClass(opt)">
                            {{ opt }}
                        </button>
                    </div>
                    <div v-else-if="isChoiceMode" class="mb-8"></div>

                    <button v-if="!hasSubmitted" @click="checkAnswer" class="w-full py-5 rounded-2xl font-bold text-xl shadow-xl transition-all active:scale-95"
                        :class="(isChoiceMode && !userAnswers[0]) ? 'bg-slate-600 text-slate-400 cursor-not-allowed' : 'bg-amber-600 text-slate-900 hover:bg-amber-500'"
                        :disabled="isChoiceMode && !userAnswers[0]">æ”»æ“Šï¼ˆæª¢æŸ¥ç­”æ¡ˆï¼‰</button>
                    <button v-if="!hasSubmitted && !isFinished && !monsterDead && !playerDead" @click="runAway" class="w-full mt-3 py-3 rounded-2xl font-bold text-lg bg-slate-600 text-white hover:bg-slate-500">ğŸƒ é€ƒè·‘</button>
                    <div v-else class="animate-in fade-in duration-500">
                        <div v-if="!isCurrentCorrect" class="text-center p-4 bg-red-900/50 rounded-xl mb-4 border border-red-500/50 text-red-200 font-bold">
                            <span v-if="timeUp" class="block text-sm mb-1">â± æ™‚é–“åˆ°ï¼</span>
                            ğŸ’¡ æ­£è§£æ˜¯ï¼š{{ getFormattedAnswer() }}
                        </div>
                        <div v-if="currentQuestion.grammarTip" class="grammar-card rounded-xl p-4 mb-6 text-amber-100 text-sm leading-relaxed">
                            <div class="font-bold text-amber-400 mb-1 text-xs uppercase tracking-wide">ğŸ“ æ–‡æ³•å°å¡</div>
                            {{ currentQuestion.grammarTip }}
                        </div>
                        <button v-if="difficulty === 'easy'" @click="nextQuestion" class="w-full bg-amber-500 text-slate-900 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-lg" :disabled="wrongAnswerPause">
                            {{ wrongAnswerPause ? `é–±è®€æ­£è§£ä¸­... ${wrongAnswerPauseCountdown} ç§’` : 'ä¸‹ä¸€é¡Œ' }}
                        </button>
                        <div v-else-if="wrongAnswerPause" class="w-full py-5 rounded-2xl font-bold text-xl bg-slate-600 text-slate-400 text-center">
                            {{ wrongAnswerPauseCountdown }} ç§’å¾Œè‡ªå‹•ä¸‹ä¸€é¡Œ
                        </div>
                        <button v-else @click="nextQuestion" class="w-full bg-amber-500 text-slate-900 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-lg">ä¸‹ä¸€é¡Œ</button>
                    </div>
                    </template>
                    <template v-else>
                        <div v-if="monsterDead" class="text-center py-12">
                            <div class="text-6xl mb-4">ğŸ†</div>
                            <h2 class="text-3xl font-black text-amber-400 mb-6">{{ currentLevel >= 3 ? 'å…¨ç ´ï¼' : 'é—œå¡çªç ´ï¼' }}</h2>
                            <button v-if="currentLevel < 3" @click="goNextLevel" class="bg-amber-500 text-slate-900 px-12 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-2xl">é€²å…¥ä¸‹ä¸€é—œ</button>
                            <button v-else @click="startOver" class="bg-amber-500 text-slate-900 px-12 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-2xl">è¿”å›é—œå¡é¸å–®</button>
                        </div>
                        <div v-else class="text-center py-12">
                            <div class="text-6xl mb-4">ğŸ’€</div>
                            <h2 class="text-3xl font-black text-rose-400 mb-6">å†’éšªå¤±æ•—...</h2>
                            <button @click="revive" class="bg-emerald-600 text-white px-12 py-5 rounded-2xl font-bold text-xl hover:bg-emerald-500 shadow-2xl">å¾©æ´»ï¼ˆé‡æ–°é–‹å§‹ï¼‰</button>
                        </div>
                    </template>
                </div>

                <div v-else-if="isFinished" class="text-center py-12">
                    <div class="text-7xl mb-6">{{ levelPassed ? 'ğŸ‰' : 'ğŸ˜¢' }}</div>
                    <h2 class="text-4xl font-black text-slate-200 mb-2">{{ levelPassed ? 'æœ¬é—œé€šéï¼' : 'åˆ†æ•¸ä¸è¶³' }}</h2>
                    <p class="text-slate-400 mb-4">æœ¬é—œå¾—åˆ† {{ totalScore }} åˆ†</p>
                    <template v-if="!levelPassed">
                        <p class="text-rose-400 font-bold mb-6">éœ€é” 1000 åˆ†æ‰èƒ½é€²å…¥ä¸‹ä¸€é—œ</p>
                        <button @click="retryLevel" class="bg-slate-600 text-white px-12 py-5 rounded-2xl font-bold text-xl hover:bg-slate-500 shadow-2xl">å†è©¦ä¸€æ¬¡</button>
                    </template>
                    <template v-else>
                        <button v-if="currentLevel < 3" @click="goNextLevel" class="bg-amber-500 text-slate-900 px-12 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-2xl">é€²å…¥ä¸‹ä¸€é—œ</button>
                        <button v-else @click="startOver" class="bg-amber-500 text-slate-900 px-12 py-5 rounded-2xl font-bold text-xl hover:bg-amber-400 shadow-2xl">è¿”å›é—œå¡é¸å–®</button>
                    </template>
                </div>
            </div>
        </div>
    </div>
    <div v-if="flashOverlay" class="flash-overlay"></div>

    <script>
        const { createApp, ref, computed } = Vue;

        createApp({
            setup() {
                const db = {
                    places: [{j: "éƒ¨å±‹", r: "ã¸ã‚„", t: "æˆ¿é–“"}, {j: "å­¦æ ¡", r: "ãŒã£ã“ã†", t: "å­¸æ ¡"}, {j: "å›³æ›¸é¤¨", r: "ã¨ã—ã‚‡ã‹ã‚“", t: "åœ–æ›¸é¤¨"}, {j: "åº­", r: "ã«ã‚", t: "é™¢å­"}, {j: "æ•™å®¤", r: "ãã‚‡ã†ã—ã¤", t: "æ•™å®¤"}],
                    objects: [
                        {j: "æœ¬", r: "ã»ã‚“", t: "æ›¸", type: "read", exists: true},
                        {j: "æ–™ç†", r: "ã‚Šã‚‡ã†ã‚Š", t: "æ–™ç†", type: "eat", exists: true},
                        {j: "éŸ³æ¥½", r: "ãŠã‚“ãŒã", t: "éŸ³æ¨‚", type: "hear", exists: false},
                        {j: "æ‰‹ç´™", r: "ã¦ãŒã¿", t: "ä¿¡", type: "write", exists: true},
                        {j: "æ—¥è¨˜", r: "ã«ã£ã", t: "æ—¥è¨˜", type: "write", exists: true},
                        {j: "ãƒ‘ãƒ³", r: "ã±ã‚“", t: "éºµåŒ…", type: "eat", exists: true},
                        {j: "ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ", r: "ã·ã‚Œãœã‚“ã¨", t: "ç¦®ç‰©", type: "give", exists: true}
                    ],
                    people: [{j: "å‹é”", r: "ã¨ã‚‚ã ã¡", t: "æœ‹å‹"}, {j: "å…ˆç”Ÿ", r: "ã›ã‚“ã›ã„", t: "è€å¸«"}, {j: "æ¯", r: "ã¯ã¯", t: "åª½åª½"}],
                    tools: [{j: "ãƒšãƒ³", r: "ãºã‚“", t: "ç­†"}, {j: "ã‚¹ãƒãƒ›", r: "ã™ã¾ã»", t: "æ‰‹æ©Ÿ"}, {j: "ã¯ã—", r: "ã¯ã—", t: "ç­·å­"}],
                    grammarTips: {
                        move: "ã€Œã¸ã€æˆ–ã€Œã«ã€è¡¨ç¤ºç§»å‹•çš„ç›®æ¨™ã€æ–¹å‘ï¼Œæ¥åœ¨å ´æ‰€å¾Œè¡¨ç¤ºã€Œå¾€ï½å»ã€ã€‚",
                        placeAction: "ã€Œã§ã€è¡¨ç¤ºå‹•ä½œç™¼ç”Ÿçš„å ´æ‰€ï¼›ã€Œã‚’ã€è¡¨ç¤ºå‹•ä½œçš„å—è©ï¼ˆè®€ä»€éº¼ã€åƒä»€éº¼ï¼‰ã€‚",
                        existence: "ã€Œã«ã€è¡¨ç¤ºç‰©å“å­˜åœ¨çš„å ´æ‰€ï¼›ã€ŒãŒã€è¡¨ç¤ºä¸»èªï¼ˆæœ‰ä»€éº¼ï¼‰ã€‚",
                        accompany: "ã€Œã¨ã€è¡¨ç¤ºä¸€èµ·åšäº‹çš„å°è±¡ï¼ˆå’Œèª°ï¼‰ï¼›ã€Œã‚’ã€è¡¨ç¤ºå‹•ä½œçš„å—è©ã€‚",
                        tool: "ã€Œã§ã€è¡¨ç¤ºä½¿ç”¨çš„å·¥å…·æˆ–æ‰‹æ®µï¼ˆç”¨ä»€éº¼ï¼‰ï¼›ã€Œã‚’ã€è¡¨ç¤ºå‹•ä½œçš„å—è©ã€‚",
                        give: "ã€Œã«ã€è¡¨ç¤ºçµ¦äºˆçš„å°è±¡ï¼ˆçµ¦èª°ï¼‰ï¼›ã€Œã‚’ã€è¡¨ç¤ºçµ¦äºˆçš„ç‰©å“ã€‚"
                    }
                };

                const LEVEL_CONFIG = {
                    1: { blanks: 1, types: [0, 1, 2], title: 'æ£®æ—' },
                    2: { blanks: 1, types: [0, 1, 2, 3, 4, 5], title: 'æ´çªŸ' },
                    3: { blanks: 2, types: [0, 1, 2, 3, 4, 5], title: 'é­”ç‹åŸ' }
                };
                const MONSTER_NAMES = { 1: 'åŠ©è©æ€ª', 2: 'åŠ©è©å¦–', 3: 'åŠ©è©é­”ç‹' };
                const MONSTER_HP = 100;
                const DAMAGE_TO_MONSTER = 20;
                const DAMAGE_TO_PLAYER = 20;
                const GOLD_PER_HIT = 10;
                const EXP_PER_HIT = 15;
                const POTION_HP = 30;
                const INITIAL_POTIONS = 3;
                const COMBO_PERFECT = 3;
                const PASS_SCORE = 1000;

                // monster definitions for DQé¢¨ appearance
                const MONSTERS = [
                    { id:1, name:'åŠ©è©æ€ª', sprite:'ğŸ‘¹', hpMax:100, attack:20, trait:'æ™®é€šå‹'},
                    { id:2, name:'åŠ©è©å¦–', sprite:'ğŸ§Œ', hpMax:120, attack:25, trait:'æœƒé–ƒé¿'},
                    { id:3, name:'åŠ©è©é­”', sprite:'ğŸ‘º', hpMax:140, attack:30, trait:'æ”»æ“Šé«˜'},
                    { id:4, name:'åŠ©è©é¾', sprite:'ğŸ‰', hpMax:160, attack:35, trait:'ç«ç„°åæ¯'},
                    { id:5, name:'åŠ©è©é¬¼', sprite:'ğŸ‘»', hpMax:180, attack:40, trait:'ç„¡å½¢'},
                    { id:6, name:'åŠ©è©ç‹', sprite:'ğŸ‘‘', hpMax:200, attack:50, trait:'ç‹è€…æ°£æ¯'}
                ];

                const showLevelSelect = ref(true);
                const player = ref({ hp: 100, maxHp: 100, gold: 0, exp: 0 });
                const monster = ref({ hp: MONSTER_HP, maxHp: MONSTER_HP, name: 'åŠ©è©æ€ª' });
                const inventory = ref({ potions: INITIAL_POTIONS });
                const battleLog = ref('ç”¨æ­£ç¢ºçš„åŠ©è©æ”»æ“Šæ€ªç‰©å§ï¼');
                const monsterShake = ref(false);
                const playerBlink = ref(false);
                const hpBarDanger = ref(false);
                const goldDoubleNext = ref(false);
                const difficulty = ref('easy');

                const questions = ref([]);
                const currentIndex = ref(0);
                const userAnswers = ref([]);
                const hasSubmitted = ref(false);
                const totalScore = ref(0);
                const comboCount = ref(0);
                const currentLevel = ref(1);
                const isFinished = ref(false);
                const isCurrentCorrect = ref(false);
                const timeLeft = ref(10);
                const timeUp = ref(false);
                const wrongAnswerPause = ref(false);
                const wrongAnswerPauseCountdown = ref(0);
                const mistakes = ref([]);
                const showMistakesPanel = ref(false);
                const monsterHit = ref(false);
                const screenShake = ref(false);
                const flashOverlay = ref(false);
                // audio system
                const audioInited = ref(false);
                const bgmAudio = ref(null);
                const gameOverAudio = ref(null);
                const bgmVolume = ref(0.5);
                const sfxVolume = ref(0.5);
                const isMuted = ref(false);
                const audioSettingsKey = 'jpRpgAudioV1';
                let timerId = null;
                let pauseTimerId = null;

                const loadAudioSettings = () => {
                    try {
                        const raw = localStorage.getItem(audioSettingsKey);
                        if (raw) {
                            const obj = JSON.parse(raw);
                            bgmVolume.value = obj.bgmVolume ?? bgmVolume.value;
                            sfxVolume.value = obj.sfxVolume ?? sfxVolume.value;
                            isMuted.value = obj.isMuted ?? isMuted.value;
                        }
                    } catch (_){ }
                };
                const saveAudioSettings = () => {
                    try {
                        localStorage.setItem(audioSettingsKey, JSON.stringify({bgmVolume: bgmVolume.value, sfxVolume: sfxVolume.value, isMuted: isMuted.value}));
                    } catch (_){ }
                };

                const initAudio = () => {
                    if (audioInited.value) return;
                    audioInited.value = true;
                    // create bgm
                    try {
                        bgmAudio.value = new Audio('assets/audio/bgm.mp3');
                        bgmAudio.value.loop = true;
                        bgmAudio.value.volume = isMuted.value ? 0 : bgmVolume.value;
                        bgmAudio.value.play().catch(() => {
                            console.log('BGM ç„¡æ³•æ’­æ”¾ï¼Œå¯èƒ½ç¼ºå°‘æª”æ¡ˆæˆ–æ¬Šé™');
                        });
                    } catch (_){ console.log('ç„¡æ³•å»ºç«‹ BGM'); }
                };
                const stopAllAudio = () => {
                    try {
                        if (bgmAudio.value) {
                            bgmAudio.value.pause();
                            try { bgmAudio.value.currentTime = 0; } catch(_){}
                        }
                    } catch (_){ }
                    try {
                        if (gameOverAudio.value) {
                            gameOverAudio.value.pause();
                            try { gameOverAudio.value.currentTime = 0; } catch(_){}
                            gameOverAudio.value = null;
                        }
                    } catch (_){ }
                };
                const handleGameOver = () => {
                    // stop bgm first to ensure gameover sound is audible
                    try { if (bgmAudio.value) { bgmAudio.value.pause(); try { bgmAudio.value.currentTime = 0; } catch(_){} } } catch(_){ }
                    try {
                        gameOverAudio.value = new Audio('assets/audio/sfx_gameover.mp3');
                        gameOverAudio.value.volume = isMuted.value ? 0 : sfxVolume.value;
                        gameOverAudio.value.play().catch(() => { console.log('ç„¡æ³•æ’­æ”¾ gameover éŸ³æ•ˆï¼Œå¯èƒ½ç¼ºå°‘æª”æ¡ˆ'); });
                    } catch (_){ console.log('å»ºç«‹ gameover éŸ³æ•ˆå¤±æ•—'); }
                };
                const runAway = () => {
                    // stop timers and all audio, reset fight state and go home
                    clearTimer(); if (pauseTimerId) { clearInterval(pauseTimerId); pauseTimerId = null; }
                    stopAllAudio();
                    battleLog.value = 'ä½ é€ƒè·‘äº†ï¼';
                    hasSubmitted.value = false;
                    isFinished.value = false;
                    userAnswers.value = [];
                    showLevelSelect.value = true;
                };
                const playBgm = () => {
                    if (!audioInited.value) initAudio();
                    if (bgmAudio.value) {
                        bgmAudio.value.volume = isMuted.value ? 0 : bgmVolume.value;
                        if (bgmAudio.value.paused) bgmAudio.value.play().catch(()=>{});
                    }
                };
                const pauseBgm = () => {
                    if (bgmAudio.value && !bgmAudio.value.paused) bgmAudio.value.pause();
                };
                const playSfx = (name) => {
                    if (!audioInited.value) initAudio();
                    const srcMap = {
                        hit:'assets/audio/sfx_hit.mp3',
                        miss:'assets/audio/sfx_miss.mp3',
                        potion:'assets/audio/sfx_potion.mp3',
                        click:'assets/audio/sfx_click.mp3'
                    };
                    const src = srcMap[name];
                    if (!src) return;
                    try {
                        const a = new Audio(src);
                        a.volume = isMuted.value ? 0 : sfxVolume.value;
                        a.play().catch(()=>{console.log(`ç„¡æ³•æ’­æ”¾ ${name}`);});
                    } catch (_){ console.log(`å»ºç«‹ sfx ${name} å¤±æ•—`); }
                };

                const clearTimer = () => {
                    if (timerId) { clearInterval(timerId); timerId = null; }
                };
                const startTimer = () => {
                    clearTimer();
                    timeUp.value = false;
                    if (isFinished.value) return;
                    timeLeft.value = 10;
                    timerId = setInterval(() => {
                        timeLeft.value--;
                        if (timeLeft.value <= 0) {
                            clearTimer();
                            if (!hasSubmitted.value) {
                                timeUp.value = true;
                                hasSubmitted.value = true;
                                isCurrentCorrect.value = false;
                                applyWrongAnswerPenalty();
                            }
                        }
                    }, 1000);
                };

                const applyWrongAnswerPenalty = () => {
                    // DQ ç‰¹æ•ˆï¼šç•«é¢éœ‡å‹• + ç™½é–ƒ
                    screenShake.value = true;
                    flashOverlay.value = true;
                    setTimeout(() => { screenShake.value = false; }, 250);
                    setTimeout(() => { flashOverlay.value = false; }, 300);
                    // record mistake before applying damage
                    addMistake();
                    playWrongBeep();
                    const dmg = DAMAGE_TO_PLAYER;
                    player.value.hp = Math.max(0, player.value.hp - dmg);
                    battleLog.value = `æ€ªç‰©ç™¼å‹•æ”»æ“Šï¼Œä½ æå¤±äº† ${dmg} é» HPï¼`;
                    if (player.value.hp <= 0) {
                        // centralized game over
                        handleGameOver();
                    }
                    playerBlink.value = true;
                    hpBarDanger.value = true;
                    setTimeout(() => { playerBlink.value = false; }, 1100);
                    const isHard = difficulty.value === 'hard';
                    wrongAnswerPause.value = true;
                    wrongAnswerPauseCountdown.value = isHard ? 3 : 2;
                    pauseTimerId = setInterval(() => {
                        wrongAnswerPauseCountdown.value--;
                        if (wrongAnswerPauseCountdown.value <= 0) {
                            clearInterval(pauseTimerId);
                            wrongAnswerPause.value = false;
                            if (isHard && !playerDead.value) nextQuestion();
                        }
                    }, 1000);
                };

                // mistakes storage helpers
                const loadMistakes = () => {
                    try {
                        const data = JSON.parse(localStorage.getItem('jpRpgMistakesV1') || '[]');
                        mistakes.value = data;
                    } catch (_){ }
                };
                const saveMistakes = () => {
                    try { localStorage.setItem('jpRpgMistakesV1', JSON.stringify(mistakes.value)); } catch (_){ }
                };
                const addMistake = () => {
                    const q = currentQuestion.value;
                    const entry = {
                        prompt: q.chinese,
                        correct: q.answers,
                        choices: q.choices || null,
                        grammarTip: q.grammarTip || null,
                        timestamp: new Date().toISOString(),
                        levelId: currentLevel.value
                    };
                    mistakes.value.unshift(entry);
                    if (mistakes.value.length > 20) mistakes.value.length = 20;
                    saveMistakes();
                };
                const clearMistakes = () => { mistakes.value = []; saveMistakes(); };

                const ALL_PARTICLES = ['ã¯', 'ãŒ', 'ã‚’', 'ã«', 'ã§', 'ã¸', 'ã¨'];
                const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
                const shuffle = (arr) => [...arr].sort(() => Math.random() - 0.5);
                const makeChoices = (correct) => {
                    const correctArr = Array.isArray(correct) ? correct : [correct];
                    const wrong = ALL_PARTICLES.filter(p => !correctArr.includes(p));
                    const picked = [correctArr[0], ...shuffle(wrong).slice(0, 3)];
                    return shuffle(picked);
                };

                const levelConfig = computed(() => LEVEL_CONFIG[currentLevel.value] || LEVEL_CONFIG[1]);
                const levelTitle = computed(() => levelConfig.value.title || '');
                const isChoiceMode = computed(() => levelConfig.value.blanks === 1);

                let audioCtx = null;
                const getAudioContext = () => {
                    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    return audioCtx;
                };
                const playBeep = (frequency, duration, type) => {
                    try {
                        const ctx = getAudioContext();
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);
                        osc.frequency.value = frequency;
                        osc.type = type || 'sine';
                        gain.gain.setValueAtTime(0.15, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        osc.start(ctx.currentTime);
                        osc.stop(ctx.currentTime + duration);
                    } catch (_) {}
                };
                const playCorrectBeep = () => { playBeep(523, 0.15); playBeep(659, 0.15, 'sine'); };
                const playWrongBeep = () => { playBeep(200, 0.25, 'sawtooth'); };

                const startLevel = (level) => {
                    stopAllAudio();
                    initAudio();
                    playSfx('click');
                    showLevelSelect.value = false;
                    currentLevel.value = level;
                    initGame(level);
                };
                const usePotion = () => {
                    initAudio();
                    playSfx('potion');
                    if (inventory.value.potions <= 0 || player.value.hp >= player.value.maxHp) return;
                    inventory.value.potions--;
                    player.value.hp = Math.min(player.value.maxHp, player.value.hp + POTION_HP);
                    battleLog.value = `ä½¿ç”¨äº†å›å¾©è—¥æ°´ï¼Œæ¢å¾© ${POTION_HP} HPï¼`;
                };

                const initGame = (level) => {
                    // audio settings should already be loaded in setup
                    const lv = level ?? currentLevel.value;
                    currentLevel.value = lv;
                    const config = LEVEL_CONFIG[lv];
                    const typePool = config.types;
                    const blanks = config.blanks;
                    const qList = [];
                    for(let i=0; i<10; i++){
                        const type = typePool[Math.floor(Math.random() * typePool.length)];
                        let q;
                        switch(type) {
                            case 0: // ç§»å‹• (ã¸/ã«)
                                const p0 = rand(db.places);
                                q = { chinese: `å»${p0.t}`, segments: [{text:p0.j, ruby:p0.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:"è¡Œã", ruby:"ã„", isBlank:false}], answers:[["ã¸", "ã«"]], grammarTip: db.grammarTips.move };
                                if (blanks === 1) q.choices = makeChoices(["ã¸", "ã«"]);
                                break;
                            case 1: { // å ´æ‰€å‹•ä½œ (ã§/ã‚’)
                                const verbTypes = [
                                    { type: "read",  v: {j:"èª­ã‚€", r:"ã‚ˆ", full: "ã‚ˆã‚€"}, ch: "è®€" },
                                    { type: "eat",   v: {j:"é£Ÿã¹ã‚‹", r:"ãŸ", full: "ãŸã¹ã‚‹"}, ch: "åƒ" },
                                    { type: "hear",  v: {j:"èã", r:"ã", full: "ãã"}, ch: "è½" },
                                    { type: "write", v: {j:"æ›¸ã", r:"ã‹", full: "ã‹ã"}, ch: "å¯«" }
                                ];
                                const vt = rand(verbTypes);
                                const pool1 = db.objects.filter(x => x.type === vt.type);
                                const o1 = rand(pool1);
                                const p1 = rand(db.places);
                                if (blanks === 1) {
                                    const vReading = vt.v.full || vt.v.r + "ã‚€";
                                    q = { chinese: `åœ¨${p1.t}${vt.ch}${o1.t}`, segments: [{text:p1.j, ruby:p1.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text: o1.j + "ã‚’" + vt.v.j, ruby: o1.r + "ã‚’" + vReading, isBlank:false}], answers:["ã§"], grammarTip: db.grammarTips.placeAction };
                                    q.choices = makeChoices("ã§");
                                } else {
                                    q = { chinese: `åœ¨${p1.t}${vt.ch}${o1.t}`, segments: [{text:p1.j, ruby:p1.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:o1.j, ruby:o1.r, isBlank:false}, {isBlank:true, blankIndex:1}, {text:vt.v.j, ruby:vt.v.r, isBlank:false}], answers:["ã§", "ã‚’"], grammarTip: db.grammarTips.placeAction };
                                }
                                break;
                            }
                            case 2: { // å­˜åœ¨ (ã«/ãŒ)ï¼šåªä½¿ç”¨ exists:true çš„å¯¦é«”ç‰©å“
                                const p2 = rand(db.places);
                                const pool2 = db.objects.filter(x => x.exists !== false);
                                const o2 = rand(pool2);
                                if (blanks === 1) {
                                    q = { chinese: `${p2.t}æœ‰${o2.t}`, segments: [{text:p2.j, ruby:p2.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text: o2.j + "ãŒ" + "ã‚ã‚‹", ruby: o2.r + "ãŒã‚ã‚‹", isBlank:false}], answers:["ã«"], grammarTip: db.grammarTips.existence };
                                    q.choices = makeChoices("ã«");
                                } else {
                                    q = { chinese: `${p2.t}æœ‰${o2.t}`, segments: [{text:p2.j, ruby:p2.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:o2.j, ruby:o2.r, isBlank:false}, {isBlank:true, blankIndex:1}, {text:"ã‚ã‚‹", isBlank:false}], answers:["ã«", "ãŒ"], grammarTip: db.grammarTips.existence };
                                }
                                break;
                            }
                            case 3: { // ä¼´éš¨ (ã¨/ã‚’)
                                const pe3 = rand(db.people); const o3 = db.objects.filter(x => x.type === 'read').random();
                                const v3 = {j:"èª­ã‚€", r:"ã‚ˆ", full: "ã‚ˆã‚€"};
                                if (blanks === 1) {
                                    q = { chinese: `å’Œ${pe3.t}ä¸€èµ·è®€${o3.t}`, segments: [{text:pe3.j, ruby:pe3.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text: o3.j + "ã‚’" + v3.j, ruby: o3.r + "ã‚’" + v3.full, isBlank:false}], answers:["ã¨"], grammarTip: db.grammarTips.accompany };
                                    q.choices = makeChoices("ã¨");
                                } else {
                                    q = { chinese: `å’Œ${pe3.t}ä¸€èµ·è®€${o3.t}`, segments: [{text:pe3.j, ruby:pe3.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:o3.j, ruby:o3.r, isBlank:false}, {isBlank:true, blankIndex:1}, {text:"èª­ã‚€", ruby:"ã‚ˆ", isBlank:false}], answers:["ã¨", "ã‚’"], grammarTip: db.grammarTips.accompany };
                                }
                                break;
                            }
                            case 4: { // å·¥å…· (ã§/ã‚’)
                                const useRead = Math.random() < 0.5;
                                const t4 = useRead ? db.tools.find(x => x.j === "ã‚¹ãƒãƒ›") : db.tools.find(x => x.j === "ãƒšãƒ³");
                                const pool4 = db.objects.filter(x => x.type === (useRead ? "read" : "write"));
                                const o4 = rand(pool4);
                                const verb4 = useRead ? {j:"èª­ã‚€", r:"ã‚ˆ", full: "ã‚ˆã‚€", ch: "çœ‹"} : {j:"æ›¸ã", r:"ã‹", full: "ã‹ã", ch: "å¯«"};
                                if (blanks === 1) {
                                    q = { chinese: `ç”¨${t4.t}${verb4.ch}${o4.t}`, segments: [{text:t4.j, ruby:t4.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text: o4.j + "ã‚’" + verb4.j, ruby: o4.r + "ã‚’" + verb4.full, isBlank:false}], answers:["ã§"], grammarTip: db.grammarTips.tool };
                                    q.choices = makeChoices("ã§");
                                } else {
                                    q = { chinese: `ç”¨${t4.t}${verb4.ch}${o4.t}`, segments: [{text:t4.j, ruby:t4.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:o4.j, ruby:o4.r, isBlank:false}, {isBlank:true, blankIndex:1}, {text:verb4.j, ruby:verb4.r, isBlank:false}], answers:["ã§", "ã‚’"], grammarTip: db.grammarTips.tool };
                                }
                                break;
                            }
                            case 5: { // çµ¦äºˆ (ã«/ã‚’)
                                const pe5 = rand(db.people); const o5 = rand(db.objects);
                                if (blanks === 1) {
                                    q = { chinese: `çµ¦${pe5.t}${o5.t}`, segments: [{text:pe5.j, ruby:pe5.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text: o5.j + "ã‚’ã‚ã’ã‚‹", ruby: o5.r + "ã‚’ã‚ã’ã‚‹", isBlank:false}], answers:["ã«"], grammarTip: db.grammarTips.give };
                                    q.choices = makeChoices("ã«");
                                } else {
                                    q = { chinese: `çµ¦${pe5.t}${o5.t}`, segments: [{text:pe5.j, ruby:pe5.r, isBlank:false}, {isBlank:true, blankIndex:0}, {text:o5.j, ruby:o5.r, isBlank:false}, {isBlank:true, blankIndex:1}, {text:"ã‚ã’ã‚‹", isBlank:false}], answers:["ã«", "ã‚’"], grammarTip: db.grammarTips.give };
                                }
                                break;
                            }
                        }
                        qList.push(q);
                    }
                    questions.value = qList;
                    currentIndex.value = 0;
                    totalScore.value = 0;
                    comboCount.value = 0;
                    isFinished.value = false;
                    userAnswers.value = [];
                    hasSubmitted.value = false;
                    timeUp.value = false;
                    // pick monster based on level index
                    const mdef = MONSTERS[(lv - 1) % MONSTERS.length] || MONSTERS[0];
                    monster.value = { hp: mdef.hpMax, maxHp: mdef.hpMax, name: mdef.name, sprite: mdef.sprite, trait: mdef.trait };
                    battleLog.value = monster.value.name + ' å‡ºç¾äº†ï¼';
                    hpBarDanger.value = false;
                    clearTimer();
                    startTimer();
                };

                const currentQuestion = computed(() => questions.value[currentIndex.value] || {chinese:'', segments:[]});

                const getFormattedAnswer = () => {
                    return currentQuestion.value.answers.map(ans => Array.isArray(ans) ? ans.join('/') : ans).join(' ã€ ');
                };

                const getSentenceText = () => {
                    return currentQuestion.value.segments.map(s => s.isBlank ? (Array.isArray(currentQuestion.value.answers[s.blankIndex]) ? currentQuestion.value.answers[s.blankIndex][0] : currentQuestion.value.answers[s.blankIndex]) : s.text).join('');
                };
                const playVoice = () => {
                    const text = getSentenceText();
                    if (!text) return;
                    const url = 'https://translate.google.com/translate_tts?ie=UTF-8&q=' + encodeURIComponent(text) + '&tl=ja&client=tw-ob';
                    const audio = new Audio(url);
                    audio.play().catch(() => {
                        try {
                            window.speechSynthesis.cancel();
                            const u = new SpeechSynthesisUtterance(text);
                            u.lang = 'ja-JP'; u.rate = 0.8;
                            window.speechSynthesis.speak(u);
                        } catch (_) {}
                    });
                };

                const checkAnswer = () => {
                    clearTimer();
                    hpBarDanger.value = false;
                    const blanks = levelConfig.value.blanks;
                    isCurrentCorrect.value = currentQuestion.value.answers.slice(0, blanks).every((ans, i) => {
                        const userIn = (userAnswers.value[i] || "").trim();
                        return Array.isArray(ans) ? ans.includes(userIn) : userIn === ans;
                    });
                    if (isCurrentCorrect.value) {
                        initAudio();
                        playSfx('hit');
                        // DQ ç‰¹æ•ˆï¼šæ€ªç‰©å—æ“Š
                        monsterHit.value = true;
                        setTimeout(() => { monsterHit.value = false; }, 250);
                        playCorrectBeep();
                        comboCount.value++;
                        totalScore.value += Math.round(100 * (1 + (comboCount.value - 1) * 0.1));
                        const dmg = DAMAGE_TO_MONSTER;
                        monster.value.hp = Math.max(0, monster.value.hp - dmg);
                        let goldEarned = GOLD_PER_HIT;
                        if (goldDoubleNext.value) { goldEarned *= 2; goldDoubleNext.value = false; battleLog.value = `Perfectï¼é‡‘å¹£ç¿»å€ï¼ç²å¾— ${goldEarned} é‡‘å¹£ï¼`; }
                        else { battleLog.value = `ä½ å°${monster.value.name}é€ æˆäº† ${dmg} é»å‚·å®³ï¼`; }
                        player.value.gold += goldEarned;
                        player.value.exp += EXP_PER_HIT;
                        if (comboCount.value >= COMBO_PERFECT) { goldDoubleNext.value = true; battleLog.value = `Perfectï¼ä¸‹ä¸€é¡Œé‡‘å¹£ç¿»å€ï¼`; }
                        playVoice();
                    } else {
                        initAudio();
                        playSfx('miss');
                        comboCount.value = 0;
                        goldDoubleNext.value = false;
                        applyWrongAnswerPenalty();
                    }
                    hasSubmitted.value = true;
                };

                const nextQuestion = () => {
                    initAudio();
                    playSfx('click');
                    if(currentIndex.value < 9) {
                        currentIndex.value++; userAnswers.value = []; hasSubmitted.value = false;
                        startTimer();
                    } else { clearTimer(); isFinished.value = true; }
                };

                const getInputStyle = (idx) => {
                    if(!hasSubmitted.value) return '';
                    const userIn = (userAnswers.value[idx] || "").trim();
                    const ans = currentQuestion.value.answers[idx];
                    return (Array.isArray(ans) ? ans.includes(userIn) : userIn === ans) ? 'correct' : 'wrong';
                };

                const displaySegments = computed(() => {
                    const q = currentQuestion.value;
                    const blanks = levelConfig.value.blanks;
                    return (q.segments || []).map(seg => {
                        if (!seg.isBlank) return { ...seg, showInput: false };
                        return { ...seg, showInput: seg.blankIndex < blanks };
                    });
                });

                const getAnswerForDisplay = (blankIndex) => {
                    const ans = currentQuestion.value.answers[blankIndex];
                    return Array.isArray(ans) ? ans[0] : ans;
                };

                const selectChoice = (opt) => {
                    initAudio();
                    playSfx('click');
                    if (hasSubmitted.value) return;
                    userAnswers.value[0] = opt;
                };
                const getChoiceBtnClass = (opt) => {
                    if (!hasSubmitted.value) {
                        return (userAnswers.value[0] === opt) ? 'border-amber-400 bg-amber-500/30 text-amber-100' : 'border-slate-500 bg-slate-700/50 text-slate-200 hover:border-amber-500/50';
                    }
                    const correct = Array.isArray(currentQuestion.value.answers[0]) ? currentQuestion.value.answers[0] : [currentQuestion.value.answers[0]];
                    const isCorrectOpt = correct.includes(opt);
                    const isSelected = userAnswers.value[0] === opt;
                    if (isCorrectOpt) return 'border-emerald-500 bg-emerald-500/20 text-emerald-300';
                    if (isSelected) return 'border-rose-500 bg-rose-500/20 text-rose-300';
                    return 'border-slate-600 bg-slate-800/50 text-slate-400';
                };

                const monsterDead = computed(() => monster.value.hp <= 0);
                const playerDead = computed(() => player.value.hp <= 0);
                const levelPassed = computed(() => totalScore.value >= PASS_SCORE);
                const goNextLevel = () => {
                    stopAllAudio();
                    currentLevel.value++;
                    initGame(currentLevel.value);
                };
                const retryLevel = () => { stopAllAudio(); initGame(currentLevel.value); };
                const startOver = () => {
                    stopAllAudio();
                    showLevelSelect.value = true;
                    inventory.value.potions = INITIAL_POTIONS;
                };
                const revive = () => {
                    stopAllAudio();
                    player.value = { hp: 100, maxHp: 100, gold: 0, exp: 0 };
                    inventory.value.potions = INITIAL_POTIONS;
                    showLevelSelect.value = true;
                };

                // Array Helper
                if (!Array.prototype.random) {
                    Array.prototype.random = function() { return this[Math.floor(Math.random() * this.length)]; };
                }

                // ensure audio settings are in place
                loadAudioSettings();
                return { questions, currentIndex, currentQuestion, userAnswers, hasSubmitted, totalScore, comboCount, currentLevel, levelConfig, levelTitle, isChoiceMode, showLevelSelect, difficulty, player, monster, inventory, battleLog, monsterShake, playerBlink, hpBarDanger, goldDoubleNext, isFinished, isCurrentCorrect, timeLeft, timeUp, wrongAnswerPause, wrongAnswerPauseCountdown, mistakes, showMistakesPanel, monsterHit, screenShake, flashOverlay, bgmVolume, sfxVolume, isMuted, monsterDead, playerDead, levelPassed, displaySegments, getAnswerForDisplay, selectChoice, getChoiceBtnClass, checkAnswer, nextQuestion, getInputStyle, playVoice, initGame, getFormattedAnswer, goNextLevel, retryLevel, startOver, revive, startLevel, usePotion, clearMistakes, playBgm, pauseBgm, playSfx, loadAudioSettings, saveAudioSettings, handleGameOver, stopAllAudio, runAway };
            }
        }).mount('#app');
    </script>
</body>
</html>